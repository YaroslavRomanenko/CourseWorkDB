import tkinter as tk
import screeninfo
import pyautogui
import os
from datetime import datetime, date 

from tkinter import ttk, scrolledtext, Toplevel 
from PIL import Image, ImageTk
from decimal import Decimal, InvalidOperation

def center_window(self, width, height):
    """Centers a Tkinter window on the primary monitor"""
    try:
        monitors = screeninfo.get_monitors()
        primary_monitor = next((m for m in monitors if m.is_primary), None)

        if primary_monitor:
            pm_width, pm_height = primary_monitor.width, primary_monitor.height
            pm_x, pm_y = primary_monitor.x, primary_monitor.y
            x = pm_x + (pm_width - width) // 2
            y = pm_y + (pm_height - height) // 2
            x, y = max(pm_x, x), max(pm_y, y)
            self.geometry(f"{width}x{height}+{x}+{y}")
        else:
            print("Warning: Primary monitor not found, using pyautogui")
            screen_width, screen_height = pyautogui.size()
            x = (screen_width - width) // 2
            y = (screen_height - height) // 2
            self.geometry(f"{width}x{height}+{max(0, x)}+{max(0, y)}")
    except Exception as e:
        print(f"Error centering window: {e}. Using basic Tkinter placement")
        self.eval('tk::PlaceWindow . center')    
        
def setup_text_widget_editing(widget):
    """Enhances a Tkinter Entry, Text, or ScrolledText widget with common editing features"""
    def select_all(event):
        """Selects all text in the widget"""
        if isinstance(widget, tk.Entry):
            widget.select_range(0, 'end')
        elif isinstance(widget, (tk.Text, scrolledtext.ScrolledText)):
            widget.tag_add('sel', '1.0', 'end')
            widget.mark_set('insert', '1.0')
            widget.see('insert')
        return "break"

    widget.bind("<Control-a>", select_all)
    widget.bind("<Control-A>", select_all)

    context_menu = tk.Menu(widget, tearoff=0)

    def _do_cut(w):
        try: w.event_generate("<<Cut>>")
        except tk.TclError: pass
    def _do_copy(w):
        try: w.event_generate("<<Copy>>")
        except tk.TclError: pass
    def _do_paste(w):
        try: w.event_generate("<<Paste>>")
        except tk.TclError: pass
    def _do_select_all(w):
        select_all(tk.Event())

    context_menu.add_command(label="Cut", command=lambda w=widget: _do_cut(w))
    context_menu.add_command(label="Copy", command=lambda w=widget: _do_copy(w))
    context_menu.add_command(label="Paste", command=lambda w=widget: _do_paste(w))
    context_menu.add_separator()
    context_menu.add_command(label="Select All", command=lambda w=widget: _do_select_all(w))

    def show_menu(event):
        """Shows the context menu at the cursor position, enabling/disabling items"""
        w = event.widget
        can_cut_copy = False
        try:
            if isinstance(w, tk.Entry):
                can_cut_copy = bool(w.selection_present())
            elif isinstance(w, (tk.Text, scrolledtext.ScrolledText)):
                 sel = w.tag_ranges('sel')
                 can_cut_copy = bool(sel)
        except tk.TclError:
            pass
        can_paste = False
        try:
            can_paste = bool(w.clipboard_get())
        except tk.TclError:
            pass
        context_menu.entryconfig("Cut", state=tk.NORMAL if can_cut_copy else tk.DISABLED)
        context_menu.entryconfig("Copy", state=tk.NORMAL if can_cut_copy else tk.DISABLED)
        context_menu.entryconfig("Paste", state=tk.NORMAL if can_paste else tk.DISABLED)
        context_menu.entryconfig("Select All", state=tk.NORMAL)
        context_menu.tk_popup(event.x_root, event.y_root)

    widget.bind("<Button-3>", show_menu)
    widget.bind("<Button-2>", show_menu)

    def _clear_selection_on_focus_out(event):
        """Removes text selection when the widget loses focus"""
        if isinstance(event.widget, tk.Entry):
            event.widget.selection_clear()
        elif isinstance(event.widget, (tk.Text, scrolledtext.ScrolledText)):
            if event.widget.tag_ranges('sel'):
                event.widget.tag_remove('sel', '1.0', 'end')

    widget.bind("<FocusOut>", _clear_selection_on_focus_out)
    
def create_scrollable_list(parent, item_creation_func, item_data_list,
                             bg_color="white", placeholder_text="Список порожній.",
                             placeholder_font=("Verdana", 10), placeholder_fg="grey",
                             item_pack_config=None):
    """Creates a scrollable area within the parent widget and populates it with items generated by item_creation_func"""
    if item_pack_config is None:
        item_pack_config = {'fill': tk.X, 'pady': 2, 'padx': 2}

    for widget in parent.winfo_children():
        widget.destroy()

    canvas_scrollbar_frame = tk.Frame(parent, bg=bg_color)
    canvas_scrollbar_frame.pack(fill=tk.BOTH, expand=True)

    canvas = tk.Canvas(canvas_scrollbar_frame, borderwidth=0, background=bg_color, highlightthickness=0)
    scrollbar = ttk.Scrollbar(canvas_scrollbar_frame, orient="vertical", command=canvas.yview)
    inner_frame = tk.Frame(canvas, background=bg_color)

    canvas.configure(yscrollcommand=scrollbar.set)
    scrollbar.pack(side="right", fill="y")
    canvas.pack(side="left", fill="both", expand=True)
    canvas_frame_id = canvas.create_window((0, 0), window=inner_frame, anchor="nw")

    def _on_inner_frame_configure(event=None):
        """Updates the canvas scroll region when the inner frame's size changes"""
        if canvas.winfo_exists(): 
            canvas.after_idle(lambda: canvas.configure(scrollregion=canvas.bbox("all")))

    def _on_inner_canvas_configure(event):
        """Updates the width of the inner frame when the canvas width changes"""
        if canvas.winfo_exists():
            canvas_width = event.width
            canvas.itemconfig(canvas_frame_id, width=canvas_width)
            canvas.after_idle(lambda: canvas.configure(scrollregion=canvas.bbox("all")))

    def _on_inner_mousewheel(event):
        """Handles mouse wheel events on the canvas and inner frame"""
        if not canvas.winfo_exists(): return
        if event.num == 4: delta = -1
        elif event.num == 5: delta = 1
        else:
            try: delta = -1 if event.delta > 0 else 1
            except AttributeError: return
        canvas.yview_scroll(delta, "units")
        return "break"

    inner_frame.bind("<Configure>", _on_inner_frame_configure)
    canvas.bind('<Configure>', _on_inner_canvas_configure)

    for widget in [canvas, inner_frame]:
        widget.bind("<MouseWheel>", _on_inner_mousewheel)
        widget.bind("<Button-4>", _on_inner_mousewheel)
        widget.bind("<Button-5>", _on_inner_mousewheel)

    list_widgets = []
    if not item_data_list:
        placeholder_label = tk.Label(inner_frame, text=placeholder_text,
                                     font=placeholder_font, fg=placeholder_fg, bg=bg_color)
        placeholder_label.pack(pady=20)
        placeholder_label.bind("<MouseWheel>", _on_inner_mousewheel)
        placeholder_label.bind("<Button-4>", _on_inner_mousewheel)
        placeholder_label.bind("<Button-5>", _on_inner_mousewheel)
    else:
        for item_data in item_data_list:
            item_widget = item_creation_func(inner_frame, item_data)
            if item_widget:
                item_widget.pack(**item_pack_config)
                list_widgets.append(item_widget)
                item_widget.bind("<MouseWheel>", _on_inner_mousewheel)
                item_widget.bind("<Button-4>", _on_inner_mousewheel)
                item_widget.bind("<Button-5>", _on_inner_mousewheel)
                for child in item_widget.winfo_children():
                    if isinstance(child, tk.Frame):
                         for grandchild in child.winfo_children():
                              grandchild.bind("<MouseWheel>", _on_inner_mousewheel)
                              grandchild.bind("<Button-4>", _on_inner_mousewheel)
                              grandchild.bind("<Button-5>", _on_inner_mousewheel)
                    else:
                        child.bind("<MouseWheel>", _on_inner_mousewheel)
                        child.bind("<Button-4>", _on_inner_mousewheel)
                        child.bind("<Button-5>", _on_inner_mousewheel)


    inner_frame.update_idletasks()
    if canvas.winfo_exists():
        canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.yview_moveto(0)

    return canvas, inner_frame, list_widgets

def handle_mouse_wheel_event(event, canvas):
    """Handles a mouse wheel event specifically for scrolling a given canvas"""
    if not canvas or not canvas.winfo_exists():
        return "break"

    if event.num == 4:
        delta = -1
    elif event.num == 5:
        delta = 1
    else:
        try:
            delta = -1 if event.delta > 0 else 1
        except AttributeError:
            return "break"
        
    yview_result = canvas.yview()
    can_scroll = False
    if delta < 0 and yview_result[0] > 0.0001:
         can_scroll = True
    elif delta > 0 and yview_result[1] < 0.9999:
         can_scroll = True

    if can_scroll:
         canvas.yview_scroll(delta, "units")
         
    return "break"

def bind_recursive_mousewheel(widget, canvas):
    """Recursively binds mouse wheel events to a widget and all its descendants"""
    if isinstance(widget, (scrolledtext.ScrolledText, tk.Listbox, tk.Text, tk.Canvas, ttk.Scrollbar)):
        return

    try:
        widget.bind("<MouseWheel>", lambda event, c=canvas: handle_mouse_wheel_event(event, c), add='+')
        widget.bind("<Button-4>", lambda event, c=canvas: handle_mouse_wheel_event(event, c), add='+')
        widget.bind("<Button-5>", lambda event, c=canvas: handle_mouse_wheel_event(event, c), add='+')
    except tk.TclError as e:
        print(f"Warning (bind_recursive_mousewheel): Could not bind to widget {widget}: {e}")

    for child in widget.winfo_children():
        bind_recursive_mousewheel(child, canvas)

def apply_hover_effect(widget, hover_bg, original_bg, ignore_widgets=None):
    """Recursively applies hover background color, skipping ignored widgets"""
    if ignore_widgets is None:
        ignore_widgets = []
    if widget in ignore_widgets:
        return
    try:
        if widget.winfo_exists():
            if isinstance(widget, (tk.Label, tk.Frame, tk.Button, ttk.Button)):
                 try: widget.config(background=hover_bg)
                 except tk.TclError: pass
            if isinstance(widget, tk.Frame):
                for child in widget.winfo_children():
                    apply_hover_effect(child, hover_bg, original_bg, ignore_widgets)
    except tk.TclError:
        pass
    
def remove_hover_effect(widget, original_bg, ignore_widgets=None):
    """Recursively removes hover background color, skipping ignored widgets"""
    if ignore_widgets is None:
        ignore_widgets = []
    if widget in ignore_widgets:
        return
    try:
        if widget.winfo_exists():
            if isinstance(widget, (tk.Label, tk.Frame, tk.Button, ttk.Button)):
                 try: widget.config(background=original_bg)
                 except tk.TclError: pass
            if isinstance(widget, tk.Frame):
                for child in widget.winfo_children():
                    remove_hover_effect(child, original_bg, ignore_widgets)
    except tk.TclError:
        pass

    
def load_image_cached(cache_dict, image_filename, folder_path, size, placeholder_image=None):
    """Loads an image, resizes using thumbnail"""
    if not image_filename or not folder_path:
        return placeholder_image

    cache_key = f"{folder_path}_{image_filename}_{size[0]}x{size[1]}"
    if cache_key in cache_dict:
        return cache_dict[cache_key]

    full_path = os.path.join(folder_path, image_filename)

    if os.path.exists(full_path):
        try:
            img = Image.open(full_path)
            if img.mode != 'RGBA':
                img = img.convert('RGBA')
            img.thumbnail(size, Image.Resampling.LANCZOS)
            photo_img = ImageTk.PhotoImage(img)
            cache_dict[cache_key] = photo_img
            return photo_img
        except Exception as e:
            print(f"Error loading/processing image '{full_path}': {e}")
            cache_dict[cache_key] = placeholder_image
            return placeholder_image
    else:
        cache_dict[cache_key] = placeholder_image 
        return placeholder_image

def format_price_display(price_value):
    """Formats a price value for display"""
    if price_value is None:
        return "Ціна не вказана"
    try:
        price_decimal = Decimal(str(price_value))
        if price_decimal <= 0:
            return "Безкоштовно"
        else:
            return f"{price_decimal:.2f}₴"
    except (ValueError, TypeError, InvalidOperation):
        print(f"Warning: Could not format price '{price_value}'")
        return "N/A"
    
def format_date_display(date_value, date_format='%d-%m-%Y'):
    """Formats a date value for display"""
    if date_value is None:
        return "Не вказано"
    try:
        if isinstance(date_value, datetime):
            return date_value.strftime(date_format)
        elif isinstance(date_value, date):
             return date_value.strftime(date_format)
        else:
            parsed_date = None
            possible_formats = ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d', '%d-%m-%Y'] 
            for fmt in possible_formats:
                try:
                    parsed_date = datetime.strptime(str(date_value), fmt)
                    break 
                except (ValueError, TypeError):
                    continue
            if parsed_date:
                return parsed_date.strftime(date_format)
            else:
                print(f"Warning: Could not parse date '{date_value}' with known formats.")
                return str(date_value)
    except Exception as e:
         print(f"Error formatting date '{date_value}': {e}")
         return str(date_value)
     
def format_datetime_display(datetime_value, dt_format='%d %b, %Y @ %H:%M'):
    """Formats a datetime value for display with time"""
    if datetime_value is None:
        return "Невідома дата"
    try:
        if isinstance(datetime_value, datetime):
            return datetime_value.strftime(dt_format)
        else:
            parsed_dt = None
            possible_formats = ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%Y-%m-%d', '%d-%m-%Y %H:%M:%S', '%d-%m-%Y %H:%M']
            if isinstance(datetime_value, date):
                 datetime_value = datetime.combine(datetime_value, datetime.min.time())
                 return datetime_value.strftime(dt_format)

            for fmt in possible_formats:
                try:
                    parsed_dt = datetime.strptime(str(datetime_value), fmt)
                    break
                except (ValueError, TypeError):
                    continue
            if parsed_dt:
                return parsed_dt.strftime(dt_format)
            else:
                 print(f"Warning: Could not parse datetime '{datetime_value}' with known formats.")
                 return str(datetime_value)
    except Exception as e:
         print(f"Error formatting datetime '{datetime_value}': {e}")
         return str(datetime_value)

class CustomAskStringDialog(tk.Toplevel):
    """A simple custom modal dialog window that prompts the user for a string input using an Entry widget"""
    def __init__(self, parent, title=None, prompt=""):
        """Initializes the custom dialog"""
        super().__init__(parent)
        self.transient(parent)
        self.parent = parent
        self.result = None 

        if title:
            self.title(title)

        self.prompt_label = tk.Label(self, text=prompt, justify=tk.LEFT, wraplength=300)
        self.prompt_label.pack(padx=10, pady=(10, 5))

        self.entry = tk.Entry(self, width=40) 
        self.entry.pack(padx=10, pady=(0, 10), ipady=2) 
        setup_text_widget_editing(self.entry) 

        button_frame = tk.Frame(self)
        button_frame.pack(padx=10, pady=(0, 10))

        ok_button = tk.Button(button_frame, text="OK", width=10, command=self.on_ok)
        ok_button.pack(side=tk.LEFT, padx=5)
        cancel_button = tk.Button(button_frame, text="Cancel", width=10, command=self.on_cancel)
        cancel_button.pack(side=tk.LEFT, padx=5)

        self.bind("<Return>", self.on_ok)
        self.bind("<Escape>", self.on_cancel)

        self.update_idletasks() 
        center_window(self, self.winfo_reqwidth(), self.winfo_reqheight()) 

        self.protocol("WM_DELETE_WINDOW", self.on_cancel) 

        self.entry.focus_set()

        self.grab_set() 
        self.wait_window(self) 

    def on_ok(self, event=None):
        """Called when the OK button or Enter key is pressed"""
        self.result = self.entry.get()
        self.destroy_dialog()

    def on_cancel(self, event=None):
        """Called when the Cancel button, Escape key, or 'X' button is pressed"""
        self.result = None
        self.destroy_dialog()

    def destroy_dialog(self):
        """Cleans up the dialog window"""
        self.parent.focus_set()
        self.destroy()